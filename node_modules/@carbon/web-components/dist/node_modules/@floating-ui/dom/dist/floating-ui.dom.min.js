/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license
 * 
 * This bundle contains the following third-party dependencies:
 * 
 * Also refer to the following links for the license of other third-party dependencies:
 * 
 * https://www.npmjs.com/package/tslib
 * https://www.npmjs.com/package/lit
 * https://www.npmjs.com/package/@lit/context
 * https://www.npmjs.com/package/lodash-es
 * https://www.npmjs.com/package/@floating-ui/dom
 * https://www.npmjs.com/package/flatpickr
 * https://www.npmjs.com/package/lit-html
 * https://www.npmjs.com/package/lit-element
 * https://www.npmjs.com/package/@lit/reactive-element
 * https://www.npmjs.com/package/@floating-ui/core
 * https://www.npmjs.com/package/@floating-ui/utils
 */

import{computePosition as t,flip as e,offset as n,arrow as i,size as o}from"../../core/dist/floating-ui.core.min.js";import{createCoords as r,rectToClientRect as l,round as c,max as s,min as f,floor as u}from"../../utils/dist/floating-ui.utils.min.js";import{getOverflowAncestors as h,isElement as d,getDocumentElement as a,getWindow as g,getFrameElement as p,getComputedStyle as x,isHTMLElement as y,isTopLayer as m,getParentNode as w,isLastTraversableNode as v,isTableElement as b,isContainingBlock as R,getContainingBlock as L,getNodeName as T,isOverflowElement as F,getNodeScroll as E,isWebKit as W}from"../../utils/dist/floating-ui.utils.dom.min.js";function C(t){const e=x(t);let n=parseFloat(e.width)||0,i=parseFloat(e.height)||0;const o=y(t),r=o?t.offsetWidth:n,l=o?t.offsetHeight:i,s=c(n)!==r||c(i)!==l;return s&&(n=r,i=l),{width:n,height:i,$:s}}function H(t){return d(t)?t:t.contextElement}function O(t){const e=H(t);if(!y(e))return r(1);const n=e.getBoundingClientRect(),{width:i,height:o,$:l}=C(e);let s=(l?c(n.width):n.width)/i,f=(l?c(n.height):n.height)/o;return s&&Number.isFinite(s)||(s=1),f&&Number.isFinite(f)||(f=1),{x:s,y:f}}const z=r(0);function B(t){const e=g(t);return W()&&e.visualViewport?{x:e.visualViewport.offsetLeft,y:e.visualViewport.offsetTop}:z}function A(t,e,n,i){void 0===e&&(e=!1),void 0===n&&(n=!1);const o=t.getBoundingClientRect(),c=H(t);let s=r(1);e&&(i?d(i)&&(s=O(i)):s=O(t));const f=function(t,e,n){return void 0===e&&(e=!1),!(!n||e&&n!==g(t))&&e}(c,n,i)?B(c):r(0);let u=(o.left+f.x)/s.x,h=(o.top+f.y)/s.y,a=o.width/s.x,y=o.height/s.y;if(c){const t=g(c),e=i&&d(i)?g(i):i;let n=t,o=p(n);for(;o&&i&&e!==n;){const t=O(o),e=o.getBoundingClientRect(),i=x(o),r=e.left+(o.clientLeft+parseFloat(i.paddingLeft))*t.x,l=e.top+(o.clientTop+parseFloat(i.paddingTop))*t.y;u*=t.x,h*=t.y,a*=t.x,y*=t.y,u+=r,h+=l,n=g(o),o=p(n)}}return l({width:a,height:y,x:u,y:h})}function D(t,e){const n=E(t).scrollLeft;return e?e.left+n:A(a(t)).left+n}function P(t,e,n){void 0===n&&(n=!1);const i=t.getBoundingClientRect();return{x:i.left+e.scrollLeft-(n?0:D(t,i)),y:i.top+e.scrollTop}}function V(t,e,n){let i;if("viewport"===e)i=function(t,e){const n=g(t),i=a(t),o=n.visualViewport;let r=i.clientWidth,l=i.clientHeight,c=0,s=0;if(o){r=o.width,l=o.height;const t=W();(!t||t&&"fixed"===e)&&(c=o.offsetLeft,s=o.offsetTop)}return{width:r,height:l,x:c,y:s}}(t,n);else if("document"===e)i=function(t){const e=a(t),n=E(t),i=t.ownerDocument.body,o=s(e.scrollWidth,e.clientWidth,i.scrollWidth,i.clientWidth),r=s(e.scrollHeight,e.clientHeight,i.scrollHeight,i.clientHeight);let l=-n.scrollLeft+D(t);const c=-n.scrollTop;return"rtl"===x(i).direction&&(l+=s(e.clientWidth,i.clientWidth)-o),{width:o,height:r,x:l,y:c}}(a(t));else if(d(e))i=function(t,e){const n=A(t,!0,"fixed"===e),i=n.top+t.clientTop,o=n.left+t.clientLeft,l=y(t)?O(t):r(1);return{width:t.clientWidth*l.x,height:t.clientHeight*l.y,x:o*l.x,y:i*l.y}}(e,n);else{const n=B(t);i={x:e.x-n.x,y:e.y-n.y,width:e.width,height:e.height}}return l(i)}function j(t,e){const n=w(t);return!(n===e||!d(n)||v(n))&&("fixed"===x(n).position||j(n,e))}function I(t,e,n){const i=y(e),o=a(e),l="fixed"===n,c=A(t,!0,l,e);let s={scrollLeft:0,scrollTop:0};const f=r(0);if(i||!i&&!l)if(("body"!==T(e)||F(o))&&(s=E(e)),i){const t=A(e,!0,l,e);f.x=t.x+e.clientLeft,f.y=t.y+e.clientTop}else o&&(f.x=D(o));const u=!o||i||l?r(0):P(o,s);return{x:c.left+s.scrollLeft-f.x-u.x,y:c.top+s.scrollTop-f.y-u.y,width:c.width,height:c.height}}function S(t){return"static"===x(t).position}function q(t,e){if(!y(t)||"fixed"===x(t).position)return null;if(e)return e(t);let n=t.offsetParent;return a(t)===n&&(n=n.ownerDocument.body),n}function M(t,e){const n=g(t);if(m(t))return n;if(!y(t)){let e=w(t);for(;e&&!v(e);){if(d(e)&&!S(e))return e;e=w(e)}return n}let i=q(t,e);for(;i&&b(i)&&S(i);)i=q(i,e);return i&&v(i)&&S(i)&&!R(i)?n:i||L(t)||n}const N={convertOffsetParentRelativeRectToViewportRelativeRect:function(t){let{elements:e,rect:n,offsetParent:i,strategy:o}=t;const l="fixed"===o,c=a(i),s=!!e&&m(e.floating);if(i===c||s&&l)return n;let f={scrollLeft:0,scrollTop:0},u=r(1);const h=r(0),d=y(i);if((d||!d&&!l)&&(("body"!==T(i)||F(c))&&(f=E(i)),y(i))){const t=A(i);u=O(i),h.x=t.x+i.clientLeft,h.y=t.y+i.clientTop}const g=!c||d||l?r(0):P(c,f,!0);return{width:n.width*u.x,height:n.height*u.y,x:n.x*u.x-f.scrollLeft*u.x+h.x+g.x,y:n.y*u.y-f.scrollTop*u.y+h.y+g.y}},getDocumentElement:a,getClippingRect:function(t){let{element:e,boundary:n,rootBoundary:i,strategy:o}=t;const r=[..."clippingAncestors"===n?m(e)?[]:function(t,e){const n=e.get(t);if(n)return n;let i=h(t,[],!1).filter((t=>d(t)&&"body"!==T(t))),o=null;const r="fixed"===x(t).position;let l=r?w(t):t;for(;d(l)&&!v(l);){const e=x(l),n=R(l);n||"fixed"!==e.position||(o=null),(r?!n&&!o:!n&&"static"===e.position&&o&&["absolute","fixed"].includes(o.position)||F(l)&&!n&&j(t,l))?i=i.filter((t=>t!==l)):o=e,l=w(l)}return e.set(t,i),i}(e,this._c):[].concat(n),i],l=r[0],c=r.reduce(((t,n)=>{const i=V(e,n,o);return t.top=s(i.top,t.top),t.right=f(i.right,t.right),t.bottom=f(i.bottom,t.bottom),t.left=s(i.left,t.left),t}),V(e,l,o));return{width:c.right-c.left,height:c.bottom-c.top,x:c.left,y:c.top}},getOffsetParent:M,getElementRects:async function(t){const e=this.getOffsetParent||M,n=this.getDimensions,i=await n(t.floating);return{reference:I(t.reference,await e(t.floating),t.strategy),floating:{x:0,y:0,width:i.width,height:i.height}}},getClientRects:function(t){return Array.from(t.getClientRects())},getDimensions:function(t){const{width:e,height:n}=C(t);return{width:e,height:n}},getScale:O,isElement:d,isRTL:function(t){return"rtl"===x(t).direction}};function $(t,e){return t.x===e.x&&t.y===e.y&&t.width===e.width&&t.height===e.height}function _(t,e,n,i){void 0===i&&(i={});const{ancestorScroll:o=!0,ancestorResize:r=!0,elementResize:l="function"==typeof ResizeObserver,layoutShift:c="function"==typeof IntersectionObserver,animationFrame:d=!1}=i,g=H(t),p=o||r?[...g?h(g):[],...h(e)]:[];p.forEach((t=>{o&&t.addEventListener("scroll",n,{passive:!0}),r&&t.addEventListener("resize",n)}));const x=g&&c?function(t,e){let n,i=null;const o=a(t);function r(){var t;clearTimeout(n),null==(t=i)||t.disconnect(),i=null}return function l(c,h){void 0===c&&(c=!1),void 0===h&&(h=1),r();const d=t.getBoundingClientRect(),{left:a,top:g,width:p,height:x}=d;if(c||e(),!p||!x)return;const y={rootMargin:-u(g)+"px "+-u(o.clientWidth-(a+p))+"px "+-u(o.clientHeight-(g+x))+"px "+-u(a)+"px",threshold:s(0,f(1,h))||1};let m=!0;function w(e){const i=e[0].intersectionRatio;if(i!==h){if(!m)return l();i?l(!1,i):n=setTimeout((()=>{l(!1,1e-7)}),1e3)}1!==i||$(d,t.getBoundingClientRect())||l(),m=!1}try{i=new IntersectionObserver(w,{...y,root:o.ownerDocument})}catch(t){i=new IntersectionObserver(w,y)}i.observe(t)}(!0),r}(g,n):null;let y,m=-1,w=null;l&&(w=new ResizeObserver((t=>{let[i]=t;i&&i.target===g&&w&&(w.unobserve(e),cancelAnimationFrame(m),m=requestAnimationFrame((()=>{var t;null==(t=w)||t.observe(e)}))),n()})),g&&!d&&w.observe(g),w.observe(e));let v=d?A(t):null;return d&&function e(){const i=A(t);v&&!$(v,i)&&n();v=i,y=requestAnimationFrame(e)}(),n(),()=>{var t;p.forEach((t=>{o&&t.removeEventListener("scroll",n),r&&t.removeEventListener("resize",n)})),null==x||x(),null==(t=w)||t.disconnect(),w=null,d&&cancelAnimationFrame(y)}}const k=n,G=e,J=o,K=i,Q=(e,n,i)=>{const o=new Map,r={platform:N,...i},l={...r.platform,_c:o};return t(e,n,{...r,platform:l})};export{K as arrow,_ as autoUpdate,Q as computePosition,G as flip,h as getOverflowAncestors,k as offset,N as platform,J as size};
