/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license
 * 
 * This bundle contains the following third-party dependencies:
 * 
 * Also refer to the following links for the license of other third-party dependencies:
 * 
 * https://www.npmjs.com/package/tslib
 * https://www.npmjs.com/package/lit
 * https://www.npmjs.com/package/@lit/context
 * https://www.npmjs.com/package/lodash-es
 * https://www.npmjs.com/package/@floating-ui/dom
 * https://www.npmjs.com/package/flatpickr
 * https://www.npmjs.com/package/lit-html
 * https://www.npmjs.com/package/lit-element
 * https://www.npmjs.com/package/@lit/reactive-element
 * https://www.npmjs.com/package/@floating-ui/core
 * https://www.npmjs.com/package/@floating-ui/utils
 */

import{evaluate as t,getSide as e,getSideAxis as n,getOppositePlacement as a,getExpandedPlacements as i,getOppositeAxisPlacements as l,getAlignmentSides as o,getPaddingObject as r,getAlignmentAxis as s,getAlignment as f,clamp as c,min as m,max as g,rectToClientRect as d,getAxisLength as u}from"../../utils/dist/floating-ui.utils.min.js";function p(t,a,i){let{reference:l,floating:o}=t;const r=n(a),c=s(a),m=u(c),g=e(a),d="y"===r,p=l.x+l.width/2-o.width/2,y=l.y+l.height/2-o.height/2,w=l[m]/2-o[m]/2;let h;switch(g){case"top":h={x:p,y:l.y-o.height};break;case"bottom":h={x:p,y:l.y+l.height};break;case"right":h={x:l.x+l.width,y:y};break;case"left":h={x:l.x-o.width,y:y};break;default:h={x:l.x,y:l.y}}switch(f(a)){case"start":h[c]-=w*(i&&d?-1:1);break;case"end":h[c]+=w*(i&&d?-1:1)}return h}const y=async(t,e,n)=>{const{placement:a="bottom",strategy:i="absolute",middleware:l=[],platform:o}=n,r=l.filter(Boolean),s=await(null==o.isRTL?void 0:o.isRTL(e));let f=await o.getElementRects({reference:t,floating:e,strategy:i}),{x:c,y:m}=p(f,a,s),g=a,d={},u=0;for(let n=0;n<r.length;n++){const{name:l,fn:y}=r[n],{x:w,y:h,data:x,reset:v}=await y({x:c,y:m,initialPlacement:a,placement:g,strategy:i,middlewareData:d,rects:f,platform:o,elements:{reference:t,floating:e}});c=null!=w?w:c,m=null!=h?h:m,d={...d,[l]:{...d[l],...x}},v&&u<=50&&(u++,"object"==typeof v&&(v.placement&&(g=v.placement),v.rects&&(f=!0===v.rects?await o.getElementRects({reference:t,floating:e,strategy:i}):v.rects),({x:c,y:m}=p(f,g,s))),n=-1)}return{x:c,y:m,placement:g,strategy:i,middlewareData:d}};async function w(e,n){var a;void 0===n&&(n={});const{x:i,y:l,platform:o,rects:s,elements:f,strategy:c}=e,{boundary:m="clippingAncestors",rootBoundary:g="viewport",elementContext:u="floating",altBoundary:p=!1,padding:y=0}=t(n,e),w=r(y),h=f[p?"floating"===u?"reference":"floating":u],x=d(await o.getClippingRect({element:null==(a=await(null==o.isElement?void 0:o.isElement(h)))||a?h:h.contextElement||await(null==o.getDocumentElement?void 0:o.getDocumentElement(f.floating)),boundary:m,rootBoundary:g,strategy:c})),v="floating"===u?{x:i,y:l,width:s.floating.width,height:s.floating.height}:s.reference,b=await(null==o.getOffsetParent?void 0:o.getOffsetParent(f.floating)),R=await(null==o.isElement?void 0:o.isElement(b))&&await(null==o.getScale?void 0:o.getScale(b))||{x:1,y:1},A=d(o.convertOffsetParentRelativeRectToViewportRelativeRect?await o.convertOffsetParentRelativeRectToViewportRelativeRect({elements:f,rect:v,offsetParent:b,strategy:c}):v);return{top:(x.top-A.top+w.top)/R.y,bottom:(A.bottom-x.bottom+w.bottom)/R.y,left:(x.left-A.left+w.left)/R.x,right:(A.right-x.right+w.right)/R.x}}const h=e=>({name:"arrow",options:e,async fn(n){const{x:a,y:i,placement:l,rects:o,platform:g,elements:d,middlewareData:p}=n,{element:y,padding:w=0}=t(e,n)||{};if(null==y)return{};const h=r(w),x={x:a,y:i},v=s(l),b=u(v),R=await g.getDimensions(y),A="y"===v,D=A?"top":"left",E=A?"bottom":"right",P=A?"clientHeight":"clientWidth",O=o.reference[b]+o.reference[v]-x[v]-o.floating[b],T=x[v]-o.reference[v],k=await(null==g.getOffsetParent?void 0:g.getOffsetParent(y));let L=k?k[P]:0;L&&await(null==g.isElement?void 0:g.isElement(k))||(L=d.floating[P]||o.floating[b]);const B=O/2-T/2,S=L/2-R[b]/2-1,j=m(h[D],S),C=m(h[E],S),F=j,H=L-R[b]-C,V=L/2-R[b]/2+B,W=c(F,V,H),z=!p.arrow&&null!=f(l)&&V!==W&&o.reference[b]/2-(V<F?j:C)-R[b]/2<0,q=z?V<F?V-F:V-H:0;return{[v]:x[v]+q,data:{[v]:W,centerOffset:V-W-q,...z&&{alignmentOffset:q}},reset:z}}}),x=function(r){return void 0===r&&(r={}),{name:"flip",options:r,async fn(s){var f,c;const{placement:m,middlewareData:g,rects:d,initialPlacement:u,platform:p,elements:y}=s,{mainAxis:h=!0,crossAxis:x=!0,fallbackPlacements:v,fallbackStrategy:b="bestFit",fallbackAxisSideDirection:R="none",flipAlignment:A=!0,...D}=t(r,s);if(null!=(f=g.arrow)&&f.alignmentOffset)return{};const E=e(m),P=n(u),O=e(u)===u,T=await(null==p.isRTL?void 0:p.isRTL(y.floating)),k=v||(O||!A?[a(u)]:i(u)),L="none"!==R;!v&&L&&k.push(...l(u,A,R,T));const B=[u,...k],S=await w(s,D),j=[];let C=(null==(c=g.flip)?void 0:c.overflows)||[];if(h&&j.push(S[E]),x){const t=o(m,d,T);j.push(S[t[0]],S[t[1]])}if(C=[...C,{placement:m,overflows:j}],!j.every((t=>t<=0))){var F,H;const t=((null==(F=g.flip)?void 0:F.index)||0)+1,e=B[t];if(e)return{data:{index:t,overflows:C},reset:{placement:e}};let a=null==(H=C.filter((t=>t.overflows[0]<=0)).sort(((t,e)=>t.overflows[1]-e.overflows[1]))[0])?void 0:H.placement;if(!a)switch(b){case"bestFit":{var V;const t=null==(V=C.filter((t=>{if(L){const e=n(t.placement);return e===P||"y"===e}return!0})).map((t=>[t.placement,t.overflows.filter((t=>t>0)).reduce(((t,e)=>t+e),0)])).sort(((t,e)=>t[1]-e[1]))[0])?void 0:V[0];t&&(a=t);break}case"initialPlacement":a=u}if(m!==a)return{reset:{placement:a}}}return{}}}};const v=function(a){return void 0===a&&(a=0),{name:"offset",options:a,async fn(i){var l,o;const{x:r,y:s,placement:c,middlewareData:m}=i,g=await async function(a,i){const{placement:l,platform:o,elements:r}=a,s=await(null==o.isRTL?void 0:o.isRTL(r.floating)),c=e(l),m=f(l),g="y"===n(l),d=["left","top"].includes(c)?-1:1,u=s&&g?-1:1,p=t(i,a);let{mainAxis:y,crossAxis:w,alignmentAxis:h}="number"==typeof p?{mainAxis:p,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...p};return m&&"number"==typeof h&&(w="end"===m?-1*h:h),g?{x:w*u,y:y*d}:{x:y*d,y:w*u}}(i,a);return c===(null==(l=m.offset)?void 0:l.placement)&&null!=(o=m.arrow)&&o.alignmentOffset?{}:{x:r+g.x,y:s+g.y,data:{...g,placement:c}}}}},b=function(a){return void 0===a&&(a={}),{name:"size",options:a,async fn(i){const{placement:l,rects:o,platform:r,elements:s}=i,{apply:c=()=>{},...d}=t(a,i),u=await w(i,d),p=e(l),y=f(l),h="y"===n(l),{width:x,height:v}=o.floating;let b,R;"top"===p||"bottom"===p?(b=p,R=y===(await(null==r.isRTL?void 0:r.isRTL(s.floating))?"start":"end")?"left":"right"):(R=p,b="end"===y?"top":"bottom");const A=v-u.top-u.bottom,D=x-u.left-u.right,E=m(v-u[b],A),P=m(x-u[R],D),O=!i.middlewareData.shift;let T=E,k=P;if(h?k=y||O?m(P,D):D:T=y||O?m(E,A):A,O&&!y){const t=g(u.left,0),e=g(u.right,0),n=g(u.top,0),a=g(u.bottom,0);h?k=x-2*(0!==t||0!==e?t+e:g(u.left,u.right)):T=v-2*(0!==n||0!==a?n+a:g(u.top,u.bottom))}await c({...i,availableWidth:k,availableHeight:T});const L=await r.getDimensions(s.floating);return x!==L.width||v!==L.height?{reset:{rects:!0}}:{}}}};export{h as arrow,y as computePosition,w as detectOverflow,x as flip,v as offset,d as rectToClientRect,b as size};
